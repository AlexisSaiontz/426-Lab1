In this class you will be building a service which responds to graph requests. Storing and performing queries over graphs is important in fields such as pathfinding, image processing, and social networks, and the ideal storage strategy is still often an open research question.

In this lab you will start by implementing a simple single-node in-memory version of your server, which will store undirected graphs. Next lab you will use secondary storage to add durability and increase the supported graph size, and in later labs you will add features such as failure-atomicity, scalability, and transactions.

NOTE: Since in later labs you will add features to your early servers, the quality of your implementation will have a major effect on how difficult you find later labs.

We're using a simple HTTP based system, which only uses the HTTP and Content-Length headers. All requests will be in the form:

POST <function_name> HTTP/1.1
<other-headers?>
Content-Length: <length>
<other-headers?>

<length bytes of JSON encoded content>
The arguments will be in JSON. You can use the Mongoose Library in C or C++ for both request handling and JSON decoding if you so desire to. Seach for JSON and HTTP in the header file for more information.

In this lab you will implement the following functions for your undirected-graph store:

Function	    Method	Arguments                       Return
add_node	    POST	  u64 node_id	                    200 on success, 204 if the node already exists
add_edge	    POST	  u64 node_a_id, u64 node_b_id	  200 on success, 204 if the edge already exists, 400 if either node doesn't exist, or if node_a_id is the same as node_b_id
remove_node	  POST	  u64 node_id	                    200 on success, 400 if the node does not exist
remove_edge	  POST	  u64 node_a_id, u64 node_b_id	  200 on success, 400 if the edge does not exist
get_node	    POST	  u64 node_id	                    200 and a boolean JSON field in_graph indicating whether the node is in the graph
get_edge	    POST	  u64 node_a_id, u64 node_b_id	  200 and a boolean JSON field in_graph indicating whether the edge is in the graph, 400 of at least one of the vertices does not exist
get_neighbors	POST	  u64 node_id	                    200 and a list of neighbors* or 400 if the node does not exist
shortest_path	POST	  u64 node_a_id, u64 node_b_id	  200 and a field distance containing the length of shortest path between the two nodes or, 204 if there is no path , 400 if either node does not exist

Any In the current server version, the endpoints must be prefixed with /api/v1/, see the examples for more detail.

* Specifically the contents returned from get_neighbors must be in the form

{
  "node_id": <node_id>,
  "neighbors": [<neighbors>]
}
